# PaperHome v3.2 - Comprehensive UX Overhaul

## Executive Summary

This plan addresses critical UX issues and implements a polished, production-ready interface:
1. **Fix broken selection refresh** - Union rect strategy for clean highlighting
2. **Add status bar** - 32px Android-style with connectivity + sensors
3. **Integrate real services** - Hue, Tado, BME688, STCC4
4. **Polish input handling** - Analog stick + continuous triggers

---

## Architecture Overview

```
┌─────────────────────────────────────────────────────────────────────────┐
│                              CORE 0 (I/O)                                │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐    │
│  │ WiFiManager │  │ HueService  │  │ TadoService │  │SensorManager│    │
│  │             │  │             │  │             │  │             │    │
│  │ • Connect   │  │ • SSDP disc │  │ • Auth      │  │ • STCC4 I2C │    │
│  │ • RSSI poll │  │ • NVS creds │  │ • Zone poll │  │ • BME688    │    │
│  │             │  │ • Room poll │  │ • Temp ctrl │  │ • 30s poll  │    │
│  └──────┬──────┘  └──────┬──────┘  └──────┬──────┘  └──────┬──────┘    │
│         │                │                │                │            │
│         ▼                ▼                ▼                ▼            │
│  ┌──────────────────────────────────────────────────────────────────┐  │
│  │                        ServiceDataQueue                           │  │
│  │   WiFiStatus | HueRooms[] | TadoZones[] | SensorData              │  │
│  └──────────────────────────────────────────────────────────────────┘  │
│                                    │                                    │
│  ┌─────────────┐                   │                                    │
│  │ XboxDriver  │                   │                                    │
│  │ InputHandler│──► InputQueue ────┼────────────────────────────────►  │
│  └─────────────┘                   │                                    │
└────────────────────────────────────┼────────────────────────────────────┘
                                     │
                                     ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                              CORE 1 (UI)                                 │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  ┌──────────────────────────────────────────────────────────────────┐  │
│  │                         UIState (shared)                          │  │
│  │   • wifiRSSI, mqttConnected, hueConnected, tadoConnected         │  │
│  │   • rooms[], zones[], sensorData                                  │  │
│  │   • errors[], lastUpdate timestamps                               │  │
│  └──────────────────────────────────────────────────────────────────┘  │
│                                                                          │
│  ┌───────────────────────────────────────────────────────────────────┐ │
│  │                           StatusBar (32px)                         │ │
│  │  ┌─────────────────────┐              ┌─────────────────────────┐ │ │
│  │  │ [WiFi] [MQTT] [Hue] │              │ 23.5°C  650ppm  [85%]  │ │ │
│  │  │   [Tado]            │              │                         │ │ │
│  │  └─────────────────────┘              └─────────────────────────┘ │ │
│  └───────────────────────────────────────────────────────────────────┘ │
│                                                                          │
│  ┌───────────────────────────────────────────────────────────────────┐ │
│  │                        Content Area (736px)                        │ │
│  │                                                                    │ │
│  │   ┌─────────────────────────────────────────────────────────────┐ │ │
│  │   │              HueDashboard / SensorDashboard / Tado          │ │ │
│  │   │                      OR Settings screens                     │ │ │
│  │   └─────────────────────────────────────────────────────────────┘ │ │
│  │                                                                    │ │
│  └───────────────────────────────────────────────────────────────────┘ │
│                                                                          │
│  ┌───────────────────────────────────────────────────────────────────┐ │
│  │                       Page Indicator (32px)                        │ │
│  │                          ● ○ ○  (dots)                            │ │
│  └───────────────────────────────────────────────────────────────────┘ │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## Screen Layout Dimensions

```
Display: 480 x 800 pixels (portrait, rotated)

┌────────────────────────────────────────┐ ─┐
│            STATUS BAR (32px)           │  │ 32px
├────────────────────────────────────────┤ ─┤
│                                        │  │
│                                        │  │
│                                        │  │
│           CONTENT AREA                 │  │ 736px
│              (736px)                   │  │
│                                        │  │
│                                        │  │
│                                        │  │
├────────────────────────────────────────┤ ─┤
│          PAGE INDICATOR (32px)         │  │ 32px
└────────────────────────────────────────┘ ─┘
                 480px
```

---

## Phase 1: Critical Fixes (Selection & Input)

### 1.1 Fix Selection Refresh

**Problem**: Currently refreshing only new selection rect, leaving old selection visible.

**Solution**: Refresh union of old + new selection rects.

```cpp
// In renderCurrentScreen() - main.cpp
void renderCurrentScreen() {
    if (!currentScreen || !compositor) return;
    if (!currentScreen->isDirty()) return;

    Rect prevSelection = currentScreen->getPreviousSelectionRect();
    Rect currSelection = currentScreen->getSelectionRect();

    compositor->beginFrame();
    compositor->fillScreen(true);
    currentScreen->render(*compositor);

    // Selection highlighting via inversion
    if (!currSelection.isEmpty()) {
        // Invert current selection pixels
        displayDriver.invertRect(currSelection);
    }

    if (needsFullRefresh) {
        compositor->endFrameFull();
        needsFullRefresh = false;
    } else {
        // KEY FIX: Refresh union of old and new selection
        Rect refreshRegion = prevSelection.unionWith(currSelection);
        if (!refreshRegion.isEmpty()) {
            displayDriver.partialRefresh(refreshRegion);
        }
    }

    currentScreen->clearDirty();
}
```

### 1.2 Implement True Pixel Inversion

**Current**: Border drawing (not true inversion)
**New**: XOR each pixel in the rect

```cpp
// display_driver.cpp
void DisplayDriver::invertRect(const Rect& rect) {
    // GxEPD2 buffer access for true XOR inversion
    // The display buffer is accessible via the GFX canvas
    for (int16_t y = rect.y; y < rect.y + rect.height; y++) {
        for (int16_t x = rect.x; x < rect.x + rect.width; x++) {
            uint16_t currentColor = _display.getPixel(x, y);
            _display.drawPixel(x, y, currentColor == GxEPD_BLACK ? GxEPD_WHITE : GxEPD_BLACK);
        }
    }
}
```

**Note**: GxEPD2_BW doesn't expose `getPixel()`. Alternative approach:

```cpp
// Use a selection overlay approach instead
// Draw content first, then draw inverted rect ON TOP
void DisplayDriver::drawInvertedRect(const Rect& rect) {
    // Draw white rect with black border = inverted look on e-ink
    _display.fillRect(rect.x, rect.y, rect.width, rect.height, GxEPD_BLACK);
    _display.fillRect(rect.x + 2, rect.y + 2, rect.width - 4, rect.height - 4, GxEPD_WHITE);
}
```

**Best approach**: Re-render the tile content with inverted colors when selected.

### 1.3 Add Left Analog Stick Navigation

**File**: `src/controller/input_handler.cpp`

```cpp
InputAction InputHandler::processNavigation(const ControllerSnapshot& current) {
    // ... existing code ...

    // Combine D-pad AND left stick (both work identically)
    bool navLeft = current.dpadLeft || (current.stickLX < -STICK_THRESHOLD);
    bool navRight = current.dpadRight || (current.stickLX > STICK_THRESHOLD);
    bool navUp = current.dpadUp || (current.stickLY < -STICK_THRESHOLD);
    bool navDown = current.dpadDown || (current.stickLY > STICK_THRESHOLD);

    // This is already implemented! Just verify STICK_THRESHOLD = 16000
}
```

**Status**: Already implemented in current code. Verify threshold value.

### 1.4 Continuous Trigger Brightness Control

**Current**: Rate-limited discrete steps
**New**: Continuous adjustment while held

```cpp
// input_handler.cpp - processTriggers()
InputAction InputHandler::processTriggers(const ControllerSnapshot& current) {
    uint32_t now = millis();

    // Continuous mode: emit events at TRIGGER_RATE_MS intervals while held
    if (now - _lastTriggerTime < config::controller::TRIGGER_RATE_MS) {
        return InputAction::none();
    }

    // Left trigger - decrease
    if (current.triggerL > TRIGGER_THRESHOLD) {
        int16_t intensity = map(current.triggerL, TRIGGER_THRESHOLD, 1023, 1, 10);
        _lastTriggerTime = now;
        return InputAction::trigger(InputEvent::TRIGGER_LEFT, intensity, now);
    }

    // Right trigger - increase
    if (current.triggerR > TRIGGER_THRESHOLD) {
        int16_t intensity = map(current.triggerR, TRIGGER_THRESHOLD, 1023, 1, 10);
        _lastTriggerTime = now;
        return InputAction::trigger(InputEvent::TRIGGER_RIGHT, intensity, now);
    }

    return InputAction::none();
}

// Config adjustment for smoother feel
namespace config::controller {
    constexpr uint32_t TRIGGER_RATE_MS = 100;  // 10 updates/sec while held
}
```

---

## Phase 2: Status Bar Implementation

### 2.1 StatusBar Component

**New file**: `include/ui/status_bar.h`

```cpp
#pragma once
#include "display/compositor.h"

namespace paperhome {

struct StatusBarData {
    // Connectivity
    int8_t wifiRSSI = 0;           // -100 to 0 dBm
    bool wifiConnected = false;
    bool mqttConnected = false;
    bool hueConnected = false;
    bool tadoConnected = false;

    // Sensors
    float temperature = 0.0f;       // From BME688
    uint16_t co2 = 0;              // From STCC4

    // Power
    uint8_t batteryPercent = 0;
    bool usbPowered = false;
    bool charging = false;
};

class StatusBar {
public:
    static constexpr int16_t HEIGHT = 32;
    static constexpr int16_t ICON_SIZE = 16;
    static constexpr int16_t PADDING = 8;

    void render(Compositor& compositor, const StatusBarData& data);

private:
    void renderWiFiIcon(Compositor& compositor, int16_t x, int8_t rssi, bool connected);
    void renderMQTTIcon(Compositor& compositor, int16_t x, bool connected);
    void renderServiceIcon(Compositor& compositor, int16_t x, const char* label, bool connected);
    void renderTemperature(Compositor& compositor, int16_t x, float temp);
    void renderCO2(Compositor& compositor, int16_t x, uint16_t co2);
    void renderBattery(Compositor& compositor, int16_t x, uint8_t percent, bool usb, bool charging);
};

} // namespace paperhome
```

### 2.2 Icon Designs (Solid Filled Style)

```
WiFi Icon (16x16) - Signal strength bars:
████
███ █
██ █ █
█ █ █ █
─────────

MQTT Icon (12x12) - Filled circle with dot:
  ████
 ██████
██ ●● ██
██ ●● ██
 ██████
  ████

Battery Icon (24x12):
┌──────────────────┬─┐
│████████████      │ │  (filled portion = percent)
└──────────────────┴─┘

Charging: Add lightning bolt overlay
USB: Add plug symbol
```

### 2.3 StatusBar Layout

```
┌────────────────────────────────────────────────────────────────────────────┐
│ 8px │ WiFi │ 4px │ MQTT │ 4px │ Hue │ 4px │ Tado │  ...  │ 23°C │ 650 │ Batt │ 8px │
│     │ 16px │     │ 12px │     │ 16px│     │ 16px │       │ ~40px│ ~40px│ 28px │     │
└────────────────────────────────────────────────────────────────────────────┘
       ◄─────────── LEFT ICONS ──────────►         ◄──── RIGHT VALUES ────►
```

---

## Phase 3: Service Integration

### 3.1 Service Data Queue Structure

**File**: `include/core/service_queue.h`

```cpp
#pragma once
#include <freertos/FreeRTOS.h>
#include <freertos/queue.h>
#include <vector>
#include <string>

namespace paperhome {

enum class ServiceUpdateType : uint8_t {
    WIFI_STATUS,
    MQTT_STATUS,
    HUE_ROOMS,
    HUE_COMMAND_RESULT,
    TADO_ZONES,
    TADO_COMMAND_RESULT,
    SENSOR_DATA
};

struct WiFiStatus {
    bool connected;
    int8_t rssi;
    char ssid[32];
    char ip[16];
};

struct HueRoomUpdate {
    char id[16];
    char name[32];
    bool isOn;
    uint8_t brightness;
    uint8_t lightCount;
    bool reachable;
    bool hasError;
};

struct TadoZoneUpdate {
    char id[16];
    char name[32];
    float currentTemp;
    float targetTemp;
    float humidity;
    bool heating;
    uint8_t heatingPower;
    bool hasError;
};

struct SensorUpdate {
    // STCC4
    uint16_t co2;
    float stcc4Temp;
    float stcc4Humidity;
    bool stcc4Connected;

    // BME688
    float bme688Temp;
    float bme688Humidity;
    uint16_t iaq;
    uint8_t iaqAccuracy;
    float pressure;
    bool bme688Connected;
};

// Generic update wrapper
struct ServiceUpdate {
    ServiceUpdateType type;
    union {
        WiFiStatus wifi;
        HueRoomUpdate hueRoom;
        TadoZoneUpdate tadoZone;
        SensorUpdate sensors;
        bool boolValue;  // For simple status flags
    };
};

class ServiceQueue {
public:
    bool init(size_t size = 32);
    bool send(const ServiceUpdate& update);
    bool receive(ServiceUpdate& update, uint32_t timeout_ms = 0);
    size_t count() const;

private:
    QueueHandle_t _queue = nullptr;
};

} // namespace paperhome
```

### 3.2 HueService Integration

**Polling loop on Core 0**:

```cpp
void HueService::pollRooms() {
    if (!isConnected()) return;

    auto rooms = fetchRooms();  // HTTP GET to bridge

    for (const auto& room : rooms) {
        ServiceUpdate update;
        update.type = ServiceUpdateType::HUE_ROOMS;
        update.hueRoom = {
            .id = room.id,
            .name = room.name,
            .isOn = room.state.any_on,
            .brightness = room.action.bri * 100 / 254,
            .lightCount = room.lights.size(),
            .reachable = room.state.all_on || !room.state.any_on,  // simplified
            .hasError = false
        };
        serviceQueue.send(update);
    }
}

// Poll interval: 5 seconds
```

### 3.3 TadoService Integration

**Using pre-configured credentials**:

```cpp
// config.h
namespace config::tado {
    constexpr const char* USERNAME = "your@email.com";
    constexpr const char* PASSWORD = "your_password";
    constexpr const char* HOME_ID = "123456";
}

void TadoService::authenticate() {
    // Simple password grant (pre-configured credentials)
    HTTPClient http;
    http.begin("https://auth.tado.com/oauth/token");
    http.addHeader("Content-Type", "application/x-www-form-urlencoded");

    String body = "client_id=tado-web-app&grant_type=password";
    body += "&username=" + String(config::tado::USERNAME);
    body += "&password=" + String(config::tado::PASSWORD);
    body += "&scope=home.user";

    int code = http.POST(body);
    if (code == 200) {
        // Parse and store tokens
        _accessToken = response["access_token"];
        _refreshToken = response["refresh_token"];
        _tokenExpiry = millis() + response["expires_in"].as<int>() * 1000;
    }
}
```

### 3.4 SensorManager Integration

**Already implemented** - just need to send updates to queue:

```cpp
void SensorManager::sample() {
    SensorUpdate update;
    update.type = ServiceUpdateType::SENSOR_DATA;

    // STCC4
    if (_stcc4.measureSingleShot(...)) {
        update.sensors.co2 = co2;
        update.sensors.stcc4Temp = temp;
        update.sensors.stcc4Humidity = humidity;
        update.sensors.stcc4Connected = true;
    }

    // BME688
    if (_bme688.performReading()) {
        update.sensors.bme688Temp = _bme688.temperature;
        update.sensors.bme688Humidity = _bme688.humidity;
        update.sensors.iaq = calculateIAQ();
        update.sensors.pressure = _bme688.pressure / 100.0f;
        update.sensors.bme688Connected = true;
    }

    serviceQueue.send(update);
}
```

---

## Phase 4: Screen Updates

### 4.1 HueDashboard - Simplified Tiles

```cpp
void HueDashboard::renderTile(Compositor& comp, int16_t index, int16_t x, int16_t y) {
    const HueRoom& room = _rooms[index];
    bool selected = (index == getSelectedIndex());

    // Tile background
    if (selected) {
        // Inverted: black background, white content
        comp.fillRect(x, y, TILE_WIDTH, TILE_HEIGHT, true);  // black
    } else {
        comp.drawRect(x, y, TILE_WIDTH, TILE_HEIGHT, true);  // black border
    }

    // Room name (truncate to ~10 chars)
    bool textColor = !selected;  // invert text if selected
    String name = room.name.substring(0, 10);
    comp.drawText(name.c_str(), x + 8, y + 24, &FreeSansBold9pt7b, textColor);

    // On/Off status
    const char* status = room.isOn ? "ON" : "OFF";
    comp.drawText(status, x + TILE_WIDTH - 30, y + 24, &FreeSans9pt7b, textColor);

    // Brightness bar
    int16_t barY = y + TILE_HEIGHT - 20;
    int16_t barW = TILE_WIDTH - 16;
    int16_t fillW = barW * room.brightness / 100;

    comp.drawRect(x + 8, barY, barW, 10, textColor);
    if (room.isOn && fillW > 0) {
        comp.fillRect(x + 10, barY + 2, fillW - 4, 6, textColor);
    }

    // Error overlay if disconnected
    if (room.hasError) {
        // Draw X or ! icon
        comp.drawText("!", x + TILE_WIDTH/2, y + TILE_HEIGHT/2, &FreeSansBold12pt7b, textColor);
    }
}
```

### 4.2 SensorDashboard - 2x3 Equal Panels

```cpp
// 2 columns, 3 rows = 6 panels
static constexpr int16_t COLS = 2;
static constexpr int16_t ROWS = 3;
static constexpr int16_t PANEL_W = (480 - 30) / 2;  // ~225px each
static constexpr int16_t PANEL_H = (736 - 40) / 3;  // ~232px each

// Panel contents:
// [0] CO2 (ppm)      [1] Temperature (°C)
// [2] Humidity (%)   [3] IAQ (0-500)
// [4] Pressure (hPa) [5] Battery (%)

void SensorDashboard::renderPanel(Compositor& comp, int16_t index, int16_t x, int16_t y) {
    const char* labels[] = {"CO2", "Temp", "Humidity", "IAQ", "Pressure", "Battery"};
    const char* units[] = {"ppm", "C", "%", "", "hPa", "%"};

    // Large value in center
    char valueStr[16];
    switch(index) {
        case 0: snprintf(valueStr, 16, "%d", _data.co2); break;
        case 1: snprintf(valueStr, 16, "%.1f", _data.temperature); break;
        // ... etc
    }

    // Label at top
    comp.drawText(labels[index], x + 10, y + 30, &FreeSansBold12pt7b, true);

    // Large value centered
    comp.drawTextCentered(valueStr, x, y + PANEL_H/2, PANEL_W, &FreeSansBold24pt7b, true);

    // Unit at bottom
    comp.drawTextCentered(units[index], x, y + PANEL_H - 20, PANEL_W, &FreeSans12pt7b, true);
}
```

### 4.3 TadoControl - Vertical Zone List

```cpp
void TadoControl::renderZone(Compositor& comp, int16_t index, int16_t y) {
    const TadoZone& zone = _zones[index];
    bool selected = (index == getSelectedIndex());

    constexpr int16_t ROW_H = 80;
    constexpr int16_t MARGIN = 20;

    if (selected) {
        comp.fillRect(MARGIN, y, 480 - 2*MARGIN, ROW_H, true);
    } else {
        comp.drawRect(MARGIN, y, 480 - 2*MARGIN, ROW_H, true);
    }

    bool textColor = !selected;

    // Zone name (left)
    comp.drawText(zone.name.c_str(), MARGIN + 10, y + 30, &FreeSansBold12pt7b, textColor);

    // Current temp (center-left)
    char currentStr[16];
    snprintf(currentStr, 16, "%.1f°", zone.currentTemp);
    comp.drawText(currentStr, 180, y + 50, &FreeSansBold18pt7b, textColor);

    // Target temp (center-right)
    char targetStr[16];
    snprintf(targetStr, 16, "-> %.1f°", zone.targetTemp);
    comp.drawText(targetStr, 300, y + 50, &FreeSans12pt7b, textColor);

    // Heating indicator (right)
    if (zone.heating) {
        // Draw flame icon or "HEAT" text
        comp.drawText("HEAT", 400, y + 30, &FreeSansBold9pt7b, textColor);
        char powerStr[8];
        snprintf(powerStr, 8, "%d%%", zone.heatingPower);
        comp.drawText(powerStr, 400, y + 55, &FreeSans9pt7b, textColor);
    }
}
```

---

## Phase 5: Offline States & Error Handling

### 5.1 Grayed-Out Disconnected State

```cpp
void HueDashboard::renderTile(Compositor& comp, ...) {
    // ... normal rendering ...

    // Overlay for disconnected state
    if (!_hueConnected || room.hasError) {
        // Draw diagonal lines pattern (grayed effect on e-ink)
        for (int16_t i = 0; i < TILE_WIDTH + TILE_HEIGHT; i += 8) {
            comp.drawLine(x + i, y, x, y + i, true);
        }

        // Disconnected icon
        comp.drawText("X", x + TILE_WIDTH/2 - 8, y + TILE_HEIGHT/2, &FreeSansBold18pt7b, true);
    }
}
```

### 5.2 Inline Error State

```cpp
// When command fails, set error flag on affected item
void handleHueCommandResult(const std::string& roomId, bool success) {
    if (!success) {
        // Find room and set error flag
        for (auto& room : _rooms) {
            if (room.id == roomId) {
                room.hasError = true;
                room.errorTimeout = millis() + 10000;  // Clear after 10s
                markDirty();
                break;
            }
        }
    }
}

// Clear error on next successful update
void handleHueRoomUpdate(const HueRoomUpdate& update) {
    for (auto& room : _rooms) {
        if (room.id == update.id) {
            room = update;
            room.hasError = false;  // Clear error on successful update
            markDirty();
            break;
        }
    }
}
```

---

## Implementation Order

### Week 1: Critical Fixes
1. [ ] Fix selection refresh (union rect)
2. [ ] Implement inverted selection highlighting
3. [ ] Verify analog stick navigation works
4. [ ] Implement continuous trigger brightness
5. [ ] Test with current mock data

### Week 2: Status Bar
1. [ ] Create StatusBar component
2. [ ] Design and implement icons (WiFi, MQTT, battery)
3. [ ] Add temperature and CO2 display
4. [ ] Integrate into main rendering loop
5. [ ] Adjust content area for 32px status bar

### Week 3: Service Integration
1. [ ] Create ServiceQueue for data flow
2. [ ] Integrate HueService with real bridge
3. [ ] Integrate TadoService with credentials
4. [ ] Integrate SensorManager updates
5. [ ] Test all data flows

### Week 4: Screen Polish
1. [ ] Simplify HueDashboard tiles
2. [ ] Implement 2x3 SensorDashboard
3. [ ] Implement Tado zone list
4. [ ] Add offline/error states
5. [ ] Final testing and polish

---

## Files to Create/Modify

### New Files
- `include/ui/status_bar.h`
- `src/ui/status_bar.cpp`
- `include/core/service_queue.h`
- `src/core/service_queue.cpp`

### Modified Files
- `src/main.cpp` - Add status bar, service queue processing
- `src/display/display_driver.cpp` - Fix invertRect
- `src/controller/input_handler.cpp` - Verify stick nav, adjust trigger rate
- `src/ui/screens/hue_dashboard.cpp` - Simplified tiles, error states
- `src/ui/screens/sensor_dashboard.cpp` - 2x3 layout
- `src/ui/screens/tado_control.cpp` - Vertical list layout
- `include/core/config.h` - Add Tado credentials, adjust timings

---

## Testing Checklist

- [ ] Selection moves with D-pad (all 4 directions)
- [ ] Selection moves with left analog stick
- [ ] Previous selection clears properly on move
- [ ] LT decreases Hue brightness while held
- [ ] RT increases Hue brightness while held
- [ ] LT/RT work for Tado temperature
- [ ] Status bar shows WiFi signal strength
- [ ] Status bar shows temperature from BME688
- [ ] Status bar shows CO2 from STCC4
- [ ] Status bar shows battery percentage
- [ ] Hue rooms load from real bridge
- [ ] Tado zones load from real account
- [ ] Disconnected services show grayed overlay
- [ ] Failed commands show inline error
- [ ] Page dots show correct position
